# 第一章 操作系统接口

操作系统的任务是在多个进程间共享一台计算机，并提供比硬件单独支持更有用的一套服务。一个操作系统可以管理和抽象化低级别硬件，例如一个文字处理器不需要关心正在使用哪种类型的磁盘硬件。一个操作系统在多个程序之间共享一套硬件，以便支持它们同时运行(或至少看起来在同时运行)。最后，操作系统向外提供一套接口，程序可用来与系统进行交互，这样他们就可以共享数据或协同工作。

操作系统通过一套接口向用户程序提供服务。设计一套好的接口是很困难的。一方面，我们希望接口尽量地简单且功能面小，因为非常容易就能正确的实现接口。另一方面，我们想尽可能地为应用程序提供许多复杂的功能。解决这个问题的诀窍是设计依赖于少数机制的接口，这些机制可以被组合起来，以提供更多的通用性。

本书使用xv6操作系统作为具体实例来说明操作系统的概念。该系统提供了由Ken Thompson和Dennis Ritchie的Unix操作系统最先设计出的一套基本接口，同时也模仿了Unix的架构设计。Unix提供了一套单个功能很单一，但是机制结合得很好的接口，达到了令人惊讶的通用性。这套接口非常成功，以至于现代操作系统--BSD、Linux。Mac OS X、Solaris，甚至微软的Windows--都有类似Unix的接口。了解xv6将会是了解这些系统和其他系统的一个良好开端。

如图 1.1 所示，xv6采用了传统的内核形式，内核作为一个特殊的程序给运行中的程序提供服务。我们将这些正在运行的程序称为进程，每个进程都有一块内存，其中包含了指令、数据和一个堆栈。指令是程序的计算步骤。数据是计算时所必须的变量。栈存储了程序调用。一台计算机通常有许多进程，但只有一个内核。

![image-20220507225952574](http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20220507225952574.png)

当一个进程需要使用一个内核服务时，它就去调用系统调用，即操作系统提供的一个接口。系统调用会进入内核态；内核提供完服务后返回用户态。因此，一个进程会在用户态和内核态交替执行。

内核使用CPU提供的硬件保护机制，确保在用户空间(user space)执行的每个进程只能访问自己的内存。内核程序通常具有直接访问硬件的权限；用户程序则没有这些权限。当一个用户程序调用一个系统调用时，硬件会提高权限级别，并开始执行内核中预先写好的程序。

用户程序能直接调用这套由内核提供的系统调用接口集合。xv6内核提供Unix内核系统调用的一个子集。下表列出了xv6的所有系统调用。

| 系统调用                                    | 功能描述                                      |
| --------------------------------------- | ----------------------------------------- |
| int fork()                              | 创建一个进程，返回子进程PID                           |
| int exit(int status)                    | 终止当前进程，status参数会传递给父进程，调用成功后当前进程结束，不会继续执行 |
| int wait(int \*status)                  | 等待子进程结束，结束的状态会传递到\*status中，返回子进程PID       |
| int kill(int pid)                       | 终止指定PID进程，正常返回0，出现错误时返回-1                 |
| int getpid()                            | 返回当前进程PID                                 |
| int sleep(int n)                        | 暂停运行n秒                                    |
| int exec(char \*file, char \* argv\[])  | 加载并执行一个文件，只有当出现异常时返回                      |
| char \*sbrk(int n)                      | 为当前进程内存空间分配n字节，返回新分配空间的起始地址               |
| int open(char \*file, int flags)        | 打开一个文件，flags指定文件打开模式，读还是写。返回文件描述符         |
| int write(int fd, char \*buf, int n)    | 将buf中n byte数据写到fd中，返回n                    |
| int read(int fd, char \*buf, int n)     | 从fd中最多读取n byte到fd中，返回读取字节数。               |
| int close(int fd)                       | 关闭和释放fd                                   |
| int dup(int fd)                         | 创建一个文件描述符，和fd指向同一个文件                      |
| int pipe(int p\[])                      | 创建一个管道，将读\写文件描述符放到p\[0]和p\[1]中            |
| int chdir(char \*dir)                   | 切换当前所在目录，即cd                              |
| int mkdir(char \*dir)                   | 创建新目录                                     |
| int mknod(char \*file, int ,int)        | 创建一个新设备文件                                 |
| int fstat(int fd, struct stat \*st)     |                                           |
| int stat(char \*file, struct stat \*st) |                                           |
| int link(char \*file1, char \*file2)    |                                           |
| int unlink(char \*file)                 |                                           |
|                                         |                                           |

![image-20220507232214667](http://pic-save-fury.oss-cn-shanghai.aliyuncs.com/uPic/image-20220507232214667.png)

本章的其余部分概述了xv6的服务--进程、内存、文件描述符、管道和文件系统--并通过代码片段进行说明，还会讨论如何使用shell(Unix的命令行用户界面)来使用它们。通过shell对系统调用的使用，将会证明这些接口的设计如何的巧妙。

shell是一个普通的程序，从用户那里读取命令并执行。实际上，shell是一个用户程序，而不是内核中的程序，这一事实说明了系统调用的强大：shell没有什么特别之处。很容易被替换；因此，现代Unix系统有多种shell可供选择，每种都有自己的用户界面和脚本功能。xv6 shell是对Unix Bourne shell的一个简单实现。它的实现可以在(user/sh.c:1)找到。

### 1.1 进程和内存

一个xv6进程由内存(指令、数据和堆栈)和进程的状态组成。xv6对进程进行分时管理：它在等待执行的进程集合中，透明地分配CPU。当一个进程不执行时，xv6会保存其CPU寄存器，并在下次运行时恢复。内核用进程标识符(PID)标识一个唯一的进程。

一个进程可以使用fork系统调用来创建一个新的进程。fork调用会创建一个新的子进程，其内存内容与父进程完全相同。fork在父进程和子进程中都会返回。在父进程中，fork返回子进程的PID；在子进程中，fork返回0。例如，考虑下面这个用C语言编写的程序片段

```
int pid = fork();
if(pid > 0){
  printf("parent: child = %d\n", pid);
  pid = wait((int *) 0);
  printf("child %d is done\n", pid);
}else if(pid == 0){
  printf("child: exiting\n");
  exit(0);
}else{
  printf("fork error\n");
}
```

exit系统调用会停止进程并释放资源，如内存和打开的文件。`exit`需要一个整数作为状态参数传递给父进程，通常0表示成功，1表示失败。`wait`系统调用会返回当前进程的一个已结束(或已杀死)的子进程PID，并将该进程的结束状态值作为参数传递给wait调用者；如果调用者的子进程中没有一个退出的，wait就进行等待，直到有子进程退出。如果调用者没有子进程，wait立即返回-1。如果父进程不关心子进程的结束状态值，它可以将0作为参数传给 wait。

> 注：一次wait调用只会等待一个子进程退出，假如有多个子进程，就需要调用对应次wait

在该例中，输出的结果

```
parent: child=1234
child:  exiting
```

可能会以两种顺序出现，这取决于是父程序还是子程序先调用了printf。在子程序退出后，父程序的wait函数返回，此时父程序会打印

```
parent: child 1234 is done
```

尽管最初子进程与父进程的内存内容完全相同，但父程序和子程序有各自独立的内存空间，运行时不共享寄存器：改变其中一个的值不会影响另一个。例如，当wait的返回值被存储到父进程的pid中时，它不会改变子进程中的变量pid。子进程中的pid的值仍然是0。

exec系统调用将调用进程的内存替换为一个新的程序，这个程序是从文件系统中加载的。该文件必须有一个特定的格式，指定文件的哪一部分是指令，哪一部分是数据，从哪个指令开始执行等等。xv6使用ELF格式，第3章将对此有更详细的讨论。当exec成功时，它并不返回到调用进程；而是执行刚刚加载的指令，从ELF头中声明的入口处开始执行。Exec接收两个参数：可执行文件的文件名、一个字符串数组参数。例如。

```
char *argv[3];

argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

这个片段用/bin/echo程序替代了调用程序，参数列表为echo hello。常常被大家忽略的是，参数数组argv中的第一个元素，通常是程序的名称。

xv6 shell使用上述调用来帮助用户运行新程序。shell的主要结构很简单，见`main(user/sh.c:145)`。main循环用getcmd从用户那里读取一行输入。然后调用fork，创建一个shell进程的副本。父进程调用wait，而子进程运行命令。例如，如果用户向shell输入了 "echo hello"，runcmd就会以 "echo hello "为参数被调用。 `runcmd(user/sh.c:58)`运行实际的命令。对于 "echo hello"这个例子，它将调用`exec(user/sh.c: 78)`。如果exec成功了，那么子程序将执行echo而不是runcmd。在某一刻，echo将调用exit，此时父进程将会被唤醒从wait处继续执行(user/sh.c:145)。

你可能想知道为什么不把fork和exec合并到一起；我们将在后面看到，shell在实现I/O重定向时利用了这种分离。为了避免创建一个重复的进程然后立即用exec替换它所造成的浪费，操作内核通过使用虚拟内存技术，如copy on write(见第4.6节)来优化fork的实现。

xv6隐式地分配了大量用户空间内存：fork分配了子进程对父进程拷贝所需的内存，exec分配了足够的内存来容纳可执行文件。一个进程在运行时如果需要更多的内存(也许是为了malloc)，可以调用sbrk(n)来扩大其内存n个字节；sbrk会返回新内存的位置。

### 1.2 I/O和文件描述符

文件描述符(file descriptor)是一个小的整数，代表一个由内核管理的可读取或写入的对象。一个进程可以通过打开一个文件、目录、设备，或者通过创建一个管道，复制一个已有的文件描述符来获得一个新的文件描述符。为了简单起见，我们通常将文件描述符所指的对象称为 "文件"；文件描述符消除了文件、管道和设备之间的差异，它们都以字节流方式工作。我们把输入和输出称为I/O。

在内部，xv6使用文件描述符作为每个进程表中的索引，每个进程都有一个从0开始的文件描述符序列。默认情况下，一个进程总是从文件描述符0(标准输入)读取，将输出写入文件描述符1(标准输出)，并将错误信息写入文件描述符2(标准错误)。shell利用这个惯例来实现I/O重定向和管道。shell默认它始终打开着这三个文件描述符(user/sh.c: 151)，作为控制台的默认文件描述符。

`read`和`write`系统调用从文件描述符对应的文件中读取、写入字节。调用`read(fd,buf,n)` 从文件描述符fd中最多读取n个字节，将其复制到buf中，并返回读取的字节数。每个指向文件的文件描述符都有一个偏移量。`read`从当前文件的偏移量处开始读取数据，然后将偏移量向后移动读取的字节数个数：之后的读取将会从之前读取的结尾处开始读。当没有更多的字节可读时，read会返回0表示文件结束。

调用`write (fd, buf, n)` 从buf向文件描述符fd最多写入n个字节，并返回写入的字节数。只有在发生错误时才会写入少于n字节的数据。和`read`一样，`write`也是在当前文件的偏移量上写数据，然后将该偏移量按所写的字节数向前推进：每次写都是在前一次写的后面继续写。

下面的程序片段(这段代码构成了`cat`的本质)将数据从标准输入复制到标准输出。如果有错误发生，它就向标准错误发送一个信息。

```
char buf[512];
int n;

for(;;){
  n = read(0, buf, sizeof buf);
  if(n == 0) break;
  if(n < 0){
    fprintf(2, "read error\n");
    exit(1);
  }
  if(write(1, buf, n) != n){
    fprintf(2, "write error\n");
    exit(1);
  }
}
```

对于这段代码，需要注意的是，cat不知道它是在从文件、控制台还是管道中读取信息。同样，cat也不知道它在向控制台、文件或其他地方打印。使用文件描述符0是输入，文件描述符1是输出的约定，使得cat的实现变得简单。

close系统调用释放了一个文件描述符，使其可以被open、pipe或dup系统调用重新使用(见下文)。新分配的文件描述符总是当前进程，未使用的文件描述符中最小的那个。

文件描述符和fork相互作用，使得I/O重定向很容易实现。fork将父进程的文件描述符表和它的内存一起复制，这样，子进程开始时就有和父进程完全一样的可访问文件。系统调用 exec 替换当前进程的内存，但保留其文件表。这种行为使得shell能通过fork实现I/O重定向，在子进程中重新打开选定的文件描述符，然后调用exec来运行新的程序。下面是一个简化版的shell运行`cat < input.txt`命令的代码。

```
char *argv[2];

argv[0] = "cat";
argv[1] = 0;
if(fork() == 0){
  close(0);
  open("input_txt", O_RDONLY);
  exec("cat", argv);
}
```

在子进程关闭文件描述符0之后，open会将该文件描述符用于新打开的input.txt: 0将是最小的可用文件描述符。之后，Cat在执行时，文件描述符0(标准输入)会指向input.txt。父进程的文件描述符不受这些操作影响，只会修改子进程的描述符。

xv6 shell中I/O重定向的代码就是以这种方式工作的(user/sh.c:82)。shell fork一个子shell，并通过runcmd调用exec来加载新程序。

open的第二个参数由一组标志组成，以比特表示，控制open的操作。可能的值定义在文件控制(fcntl)头文件中(kernel/fcntl.h:1-5)。O\_RDONLY、O\_WRONLY、O\_RDWR、O\_CREATE和O\_TRUNC，它们指示open打开文件进行读取或写入，或同时进行读取和写入，如果文件不存在，则创建该文件，以及将文件截断到零长度。

现在应该很清楚为什么fork和exec是独立的调用：利用这两个函数，shell将可以重定向子进程的I/O而不干扰父shell的I/O设置。我们可以想象一个假想的`forkexec`系统调用，用这样的调用做I/O重定向将会很笨拙。shell可以在调用forkexec之前修改自己的I/O设置(然后取消这些修改);或者forkexec可以将I/O重定向的指令作为参数；或者(最不吸引人的)每一个像cat这样的程序都可以做I/O重定向。

fork不仅会复制文件描述符表，而且会在父子进程之间共享文件偏移量。考虑一下这个例子。

```
if(fork() == 0){
  write(1, "hello ", 6);
  exit(0);
} else {
  wait(0);
  write(1, "world\n", 6);
}
```

代码执行结束后，文件描述符1对应的文件将包含数据hello world。父级文件的写入(由于`wait`函数，只有在子进程完成后才会运行)将追加在子进程写入的后面。这种行为有助于连续的shell命令序列能够产生连续的输出，比如(echo hello; echo world) >output.txt。

dup系统调用复制一个现有的文件描述符，然后返回一个新的描述符，指向同一个底层I/O对象。共享文件偏移量，就像fork复制的文件描述符一样。这是将hello world写进文件的另一种方法。

```
fd = dup(1);
write(1, "hello", 6);
write(fd, "world\n", 6);
```

使用相同的文件描述符，通过fork和dup操作产生的新的文件描述符，将共享偏移量。但是由open打开的同一个文件不会共享偏移量。Dup允许shell实现下面这样的命令：`ls existing-file non-existing-file > tmp1 2>&1`。`2>&1`的作用是告诉shell复制文件描述符1，产生文件描述符2，然后将2分配给这条指令。这条指令的功能是将存在的文件的名称和不存在的文件的错误信息都存储到tmp1文件中。xv6 shell没有提供对错误文件描述符的I/O重定向的功能，但现在你应该知道如何实现它了。

文件描述符是一个强大的抽象概念，因为它隐藏了底层的细节：一个写入到文件描述符1的操作可能是写到一个文件、一个像控制台这样的设备或一个管道。

### 1.3 管道

管道是一个小型的内核缓冲区，作为一对文件描述符暴露给进程，一个用于读取，一个用于写入。把数据写到管道的一端，就可以从管道的另一端读取该数据。管道为进程提供了一种通信的方式。

下面的示例代码运行`wc`程序，即标准输入连接到管道的读取端。

```
int p[2];
char *argv[2];

argv[0] = "wc";
argv[1] = 0;

pipe(p);
if(fork() == 0){
  close(0);
  dup(p[0]);
  close(p[0]);
  close(p[1]);
  exec("/bin/wc", argv);
} else {
  close(p[0]);
  write(p[1], "hello world\n", 12);
  close(p[1]);
}
```

程序调用 pipe，创建一个新的管道并将`读文件描述符p[0]和写文件描述符p[1]`记录在数组 p 中。 在 fork 之后，父子进程都有指向管道的文件描述符。 子进程调用 close 和 dup 使`文件描述符0`指向管道的`读取端`，关闭 p 中的文件描述符，并调用 exec 运行 wc。 当 wc 从其标准输入中读取时，将会是从管道中读取。 父进程关闭管道的读取端，将数据写入管道，然后关闭写入端。

如果没有可用数据，则工作在管道上的read将等待数据写入或等到所有写入端的文件描述符都关闭后返回； 在后一种情况下，read 将返回 0。 read 持续阻塞直到新数据不会再到达，是子进程在执行 wc 之前关闭管道的写端的原因之一：如果 wc 程序引用了管道的write端，wc将永远不会看到文件结束。

xv6 shell 实现了管道，例如 `grep fork sh.c | wc -l` ，结构类似于之前的代码(user/sh.c:100)。 子进程创建一个管道来连接管道的左端和右端。 然后它为管道的左端调用 fork 和 runcmd，为右端也调用 fork 和 runcmd，并等待两者都完成。 管道的右端可能是一个命令，它本身包含一个管道(例如，a | b | c)，它会fork两个新的子进程(一个用于 b，一个用于 c)。 因此，shell 可以创建进程树。 这棵树的叶子是命令，内部节点是等待左右子节点完成的进程。

管道可能看起来并不比临时文件更强大：

```shell
echo hello world | wc
```

在不借助管道时，可以这样实现

```shell
echo hello world > /tmp/xyz; wc < /tmp/xyz
```

在这种情况下，管道比临时文件有至少四个优点。首先，管道会自动进行清理；而如果采用文件重定向，shell就必须小心翼翼地在完成后删除/tmp/xyz。第二，管道可以传递任意长的数据流，而ﬁle重定向则需要足够的磁盘空闲空间来存储所有数据。第三，管道允许并行执行，而文件方法要求在第二个程序开始之前完成第一个程序。

### 1.4 文件系统

xv6的文件系统提供数据文件和目录，前者包含未解释的字节序列，后者包含对数据文件和其他目录的命名引用。这些目录形成一棵树，从一个被称为根的特殊目录开始。像/a/b/c这样的路径指的是`根目录/`中名为b的目录内名为c的文件或目录。不以/开头的路径是相对于调用进程的当前所在目录，可以用chdir系统调用来改变。以下两个代码片段都是打开同一个文件(假设所有涉及的目录都存在)。

```
chdir("/a");
chdir("b");
open("c", O_RDONLY);

open("/a/b/c", O_RDONLY);
```

第一个代码块将进程的当前目录改为/a/b;第二个代码既没有提到也没有改变进程的当前目录。

有一些系统调用来创建新的文件和目录：`mkdir`能够创建一个新的目录，用`O_CREATE`标志打开会创建一个新的数据文件，`mknod`会创建一个新的设备文件。下面这个例子说明了这三种情况。

```
mkdir("/dir/");
fd = open("/dir/file", O_RDONLY);
close(fd);
mknod("/console", 1, 1);
```

`Mknod`创建一个特殊的文件，指向一个设备。与设备文件相关的是主设备号和次设备号(即`mknod`的两个参数)，它们能唯一地识别一个设备。当一个进程尝试打开一个设备文件时，内核会将读/写系统调用转移发送到设备执行，而不是将指令传递给文件系统。

一个文件的名称与文件本身无关；我们将一个底层文件称为`inode`，它可以有多个名称，叫做链接(links)。每个链接由目录中的一个元素组成；该元素包含一个文件名和一个对inode的引用。inode持有文件的元数据，包括它的类型(文件或目录或设备)、它的长度、文件内容在磁盘上的位置，以及一个文件的链接数量。

fstat系统调用从一个文件描述符所指的inode中检索信息。将其填入stat结构,在stat.h(kernel/stat.h) 的定义为：

```c
#define T_DIR  1	//目录
#define T_FILE 2	//文件
#define T_DEVICE3 //设备

struct stat{
  int dev;			//文件系统的磁盘设备
  uint ino;			//Inode编号
  short type;		//文件类型
  short nlink;	//指向当前文件的链接数量
  uint64 size;	//文件的比特大小
}
```

`link`系统调用会创建另一个文件系统名称，与现有的文件节点相同。以下代码创建一个文件，这个文件被a和b所共有。

```c
open("a", O_CREATE|O_WRONLY);
link("a", "b");
```

对a中读写内容与对b中读写内容是一样的效果。执行完上面这段代码后，可以通过检查fstat来确定a和b是否指向相同的底层内容：两个函数都会返回相同的节点号(ino)，并且nlink值将被设置为2。

unlink系统调用将一个名字从文件系统中删除。只有当该文件的链接数为零并且没有文件描述符引用它时，该文件的inode和存放其内容的磁盘空间才会被释放。因此，添加

```c
unlink("a")
```

到代码最后一行，就可以把inode和ﬁle内容作为b来访问。此外

```c
fd = open("/tmp/xyz", O_CREATE|O_RDWR);
unlink("/tmp/xyz");
```

是一种创建无名临时节点的常用方法，当进程关闭fd或进程退出时，该临时节点将被清理掉。

Unix提供了可从shell中调用的用户级别的文件工具程序，例如mkdir、ln和rm。这种设计允许任何人通过添加新的用户态程序来增强命令行接口的功能。事后看来，这个设计似乎是理所当然的，但是在Unix时代设计的其他系统往往把这样的命令放在shell中(shell同样也运行在内核中)。

一个例外是cd，它被内置于shell中(user/sh.c:160)。cd必须改变shell本身的当前工作目录。如果cd作为一个常规命令运行，那么shell将必须先fork一个子进程，由子进程运行cd，再由cd改变子进程的工作目录。父进程(即shell)的工作目录则不会改变。

### 1.5 实例

Unix将 "标准 "文件描述符、管道和方便的shell语法结合在一起进行操作，是编写通用可重用程序的一大进步。这个想法引发了一种 "软件工具 "的文化，这也是Unix强大和流行的原因，而shell是第一种所谓的 "脚本语言"。今天，Unix系统调用接口在BSD、Linux和Mac OS X等系统中依然存在。

Unix系统调用接口已经通过便携式操作系统接口(POSIX)标准进行了标准化。Xv6不符合POSIX标准：它缺少许多系统调用(包括lseek这样的基本调用)，而且它提供的许多系统调用与标准不同。我们对xv6的主要目标是在提供基础UNIX的系统调口接口的基础上尽可能的简单明了。一些人用更多的系统调用和一些简单的C库来扩展xv6，以便运行基本的Unix程序。然而，现代内核提供了比xv6更多的系统调用以及更多种类的内核服务。例如，它们支持网络、窗口系统、用户级线程、许多设备的驱动等等。现代内核不断快速发展，提供了许多超越POSIX的功能。

Unix用一套单一的文件名和文件描述符接口统一访问多种类型的资源(文件、目录和设备)。这个想法可以扩展到更多种类的资源；一个很好的例子是Plan 9，它将 "资源是文件 "的概念应用于网络、图形等方面。然而大多数Unix衍生的操作系统并没有遵循这一原则。

文件系统和文件描述符是一套强大的抽象概念。即便如此，仍然还有其他的操作系统接口模式。Multics是Unix的前身，它对文件存储进行了抽象，使其看起来像内存，从而产生了一套非常不同的接口。Multics设计的复杂性直接影响到了Unix的设计者，他们试图建立更简单的东西。

Xv6不提供用户概念，不保护一个用户不受另一个用户的影响；用Unix的话说，所有的xv6进程都以root身份运行。

本书主要研究xv6如何实现其类Unix接口，但这些想法和概念不仅仅适用于Unix。任何操作系统都必须将进程复用到底层硬件上，将进程相互隔离，并为进程间的可控通信提供机制。在学习了xv6之后，你可以看看其他更复杂的操作系统，你会在这些系统中看到xv6的基本概念。

### 1.6 练习

1. 编写一个程序，使用UNIX系统调用，通过一对管道在两个进程之间不断互相接收发送同一个字节，每个方向一个进程。测量该程序的性能，以每秒的交换量为单位。
